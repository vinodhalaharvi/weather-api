package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"

	"github.com/vinodhalaharvi/weather-api/graph/model"
	weather "github.com/vinodhalaharvi/weather-api/weather/v2.5"
)

// GetWeather is the resolver for the getWeather field.
func (r *queryResolver) GetWeather(
	ctx context.Context,
	lat float64,
	lon float64,
	apiKey string,
	units string,
	lang string,
) (*model.WeatherData, error) {
	weatherRequest := weather.NewOpenWeatherClient25()
	currentWeatherRequest := weather.NewCurrentWeatherRequest(lat, lon, apiKey, lang, units)
	currentWeatherResponse, err := weatherRequest.GetCurrentWeather(currentWeatherRequest)
	if err != nil {
		return nil, err
	}

	// Map the fields from CurrentWeatherResponse to WeatherData
	weatherData := &model.WeatherData{
		Coord: &model.Coord{
			Lon: r.floatPtr(currentWeatherResponse.Coord.Lon),
			Lat: r.floatPtr(currentWeatherResponse.Coord.Lat),
		},
		Weather:             make([]*model.WeatherCondition, len(currentWeatherResponse.Weather)),
		Base:                r.strPtr(currentWeatherResponse.Base),
		TemperateAssessment: r.strPtr(currentWeatherResponse.TemperatureAssessment),
		Main: &model.Main{
			Temp:      r.floatPtr(currentWeatherResponse.Main.Temp),
			FeelsLike: r.floatPtr(currentWeatherResponse.Main.FeelsLike),
			TempMin:   r.floatPtr(currentWeatherResponse.Main.TempMin),
			TempMax:   r.floatPtr(currentWeatherResponse.Main.TempMax),
			Pressure:  r.intPtr(currentWeatherResponse.Main.Pressure),
			Humidity:  r.intPtr(currentWeatherResponse.Main.Humidity),
		},
		Visibility: r.intPtr(currentWeatherResponse.Visibility),
		Wind: &model.Wind{
			Speed: r.floatPtr(currentWeatherResponse.Wind.Speed),
			Deg:   r.intPtr(currentWeatherResponse.Wind.Deg),
		},
		Rain: &model.Rain{
			H: r.floatPtr(currentWeatherResponse.Rain.H),
		},
		Clouds: &model.Clouds{
			All: r.intPtr(currentWeatherResponse.Clouds.All),
		},
		Dt: r.intPtr(currentWeatherResponse.Dt),
		Sys: &model.Sys{
			Type:    r.intPtr(currentWeatherResponse.Sys.Type),
			ID:      r.intPtr(currentWeatherResponse.Sys.Id),
			Country: r.strPtr(currentWeatherResponse.Sys.Country),
			Sunrise: r.intPtr(currentWeatherResponse.Sys.Sunrise),
			Sunset:  r.intPtr(currentWeatherResponse.Sys.Sunset),
		},
		Timezone: r.intPtr(currentWeatherResponse.Timezone),
		ID:       r.intPtr(currentWeatherResponse.Id),
		Name:     r.strPtr(currentWeatherResponse.Name),
		Cod:      r.intPtr(currentWeatherResponse.Cod),
	}

	// Map the WeatherCondition
	for i, wc := range currentWeatherResponse.Weather {
		weatherData.Weather[i] = &model.WeatherCondition{
			ID:          r.intPtr(wc.Id),
			Main:        r.strPtr(wc.Main),
			Description: r.strPtr(wc.Description),
			Icon:        r.strPtr(wc.Icon),
		}
	}
	return weatherData, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
